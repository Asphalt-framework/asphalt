from __future__ import annotations

import logging
import re
import sys
import types
import warnings
from collections.abc import (
    AsyncGenerator,
    Coroutine,
    Mapping,
    Sequence,
)
from contextlib import AsyncExitStack
from contextvars import ContextVar, Token
from dataclasses import dataclass, field
from enum import Enum, auto
from functools import wraps
from inspect import (
    Parameter,
    isasyncgenfunction,
    isawaitable,
    isclass,
    iscoroutine,
    iscoroutinefunction,
    signature,
)
from types import TracebackType
from typing import (
    Any,
    Callable,
    Literal,
    NoReturn,
    Optional,
    TypeVar,
    Union,
    cast,
    get_args,
    get_origin,
    get_type_hints,
    overload,
)

from anyio import (
    create_task_group,
)
from anyio.abc import TaskGroup

from ._concurrent import (
    ExceptionHandler,
    TaskFactory,
    TaskHandle,
    TeardownAction,
    run_background_task,
)
from ._event import Event, Signal
from ._exceptions import (
    AsyncResourceError,
    NoCurrentContext,
    ResourceConflict,
    ResourceNotFound,
)
from ._utils import callable_name, coalesce_exceptions, qualified_name

if sys.version_info >= (3, 10):
    from typing import ParamSpec, TypeAlias
else:
    from typing_extensions import ParamSpec, TypeAlias

if sys.version_info >= (3, 11):
    from typing import Self
else:
    from exceptiongroup import BaseExceptionGroup
    from typing_extensions import Self

logger = logging.getLogger("asphalt.core")
FactoryCallback: TypeAlias = Callable[[], Any]
TeardownCallback: TypeAlias = Union[
    Callable[[], Any], Callable[[Optional[BaseException]], Any]
]

resource_name_re = re.compile(r"\w+")
T_Resource = TypeVar("T_Resource")
T_Retval = TypeVar("T_Retval")
T_Self = TypeVar("T_Self")
P = ParamSpec("P")
_current_context: ContextVar[Context | None] = ContextVar(
    "_current_context", default=None
)


@dataclass(frozen=True)
class ResourceContainer:
    """
    Contains the resource value, plus some metadata.

    :ivar value: the resource value
    :ivar types: type names the resource was registered with
    :vartype types: tuple[type, ...]
    :ivar str name: name of the resource
    :ivar description: free-form description of the resource
    :ivar bool is_generated: ``True`` if ``value`` was generated by a resource factory
    """

    value: Any
    types: tuple[type, ...]
    name: str
    description: str | None
    is_generated: bool = False


@dataclass(frozen=True)
class ResourceFactory:
    """
    Contains the resource value or its factory callable, plus some metadata.

    :ivar callback: the factory callback
    :ivar types: type names the resource factory was registered with
    :vartype types: Tuple[type, ...]
    :ivar str name: name of the resource factory
    :ivar description: free-form description of the resource factory
    """

    callback: Callable[..., Any]
    types: tuple[type, ...]
    name: str
    description: str | None


@dataclass
class ResourceEvent(Event):
    """
    Dispatched when a resource or resource factory has been added to a context.

    :ivar resource_types: types the resource was registered under
    :vartype resource_types: tuple[type, ...]
    :ivar str name: name of the resource
    :ivar resource_description: an optional human-readable description of the resource
    :ivar bool is_factory: ``True`` if a resource factory was added, ``False`` if a
        regular resource was added
    """

    resource_types: tuple[type, ...]
    resource_name: str
    resource_description: str | None
    is_factory: bool


class ContextState(Enum):
    inactive = auto()
    open = auto()
    closing = auto()
    closed = auto()


class Context:
    """
    Contexts give request handlers and callbacks access to resources.

    When a context is created, all resource factories and resources (except
    factory-generated resources, all of which are scoped to a specific context instance)
    are copied from the parent context.

    :var Signal resource_added: a signal (:class:`ResourceEvent`) dispatched when a
        resource has been published in this context
    """

    resource_added: Signal[ResourceEvent] = Signal(ResourceEvent)

    _resources: dict[tuple[type, str], ResourceContainer]
    _resource_factories: dict[tuple[type, str], ResourceFactory]
    _task_group: TaskGroup
    _reset_token: Token[Context]
    _exit_stack: AsyncExitStack

    def __init__(self, parent: Context | None = None) -> None:
        """
        :param parent: the context to inherit resources from, or ``None`` if this is a
            "root" context

        """
        self._state = ContextState.inactive
        self._teardown_callbacks: list[tuple[TeardownCallback, bool]] = []
        self._child_contexts = set[Context]()
        self._parent = parent or _current_context.get(None)

        if self._parent is not None:
            from ._component import ComponentContext

            # Don't set a ComponentContext as parent as they exit sooner
            while isinstance(self._parent, ComponentContext):
                self._parent = self._parent._context

            self._resources = {
                key: res
                for key, res in self._parent._resources.items()
                if not res.is_generated
            }
            self._resource_factories = self._parent._resource_factories.copy()
            self._task_group = self._parent._task_group
        else:
            self._resources = {}
            self._resource_factories = {}

    @property
    def parent(self) -> Context | None:
        """Return the parent context, or ``None`` if there is no parent."""
        return self._parent

    @property
    def closed(self) -> bool:
        """
        Return ``True`` if the teardown process has at least been initiated, ``False``
        otherwise.

        """
        return self._state in (ContextState.closing, ContextState.closed)

    def _ensure_state(self, *allowed_states: ContextState) -> None:
        if self._state in allowed_states:
            return

        if self._state is ContextState.inactive:
            raise RuntimeError("this context has not been entered yet")
        elif self._state is ContextState.open:
            raise RuntimeError("this context has already been entered")
        elif self._state is ContextState.closed:
            raise RuntimeError("this context has already been closed")
        else:
            assert self._state is ContextState.closing
            raise RuntimeError("this context is being torn down")

    async def _run_teardown_callbacks(self) -> None:
        original_exception = sys.exc_info()[1]
        exceptions: list[BaseException] = []
        while self._teardown_callbacks:
            callback, pass_exception = self._teardown_callbacks.pop()
            try:
                if pass_exception:
                    retval = cast(Callable[[Optional[BaseException]], Any], callback)(
                        original_exception
                    )
                else:
                    retval = cast(Callable[[], Any], callback)()

                if isawaitable(retval):
                    await retval
            except BaseException as e:
                exceptions.append(e)

        if exceptions:
            excgrp = BaseExceptionGroup(
                "Exceptions were raised during context teardown", exceptions
            )
            del exceptions
            raise excgrp from original_exception

    def add_teardown_callback(
        self, callback: TeardownCallback, pass_exception: bool = False
    ) -> None:
        """
        Add a callback to be called when this context closes.

        This is intended for cleanup of resources, and the list of callbacks is
        processed in the reverse order in which they were added, so the last added
        callback will be called first.

        The callback may return an awaitable. If it does, the awaitable is awaited on
        before calling any further callbacks.

        :param callback: a callable that is called with either no arguments or with the
            exception that ended this context, based on the value of ``pass_exception``
        :param pass_exception: ``True`` to pass the callback the exception that ended
            this context (or ``None`` if the context ended cleanly)

        """
        self._ensure_state(ContextState.open, ContextState.closing)
        if not callable(callback):
            raise TypeError("callback must be a callable")

        self._teardown_callbacks.append((callback, pass_exception))

    async def __aenter__(self) -> Self:
        self._ensure_state(ContextState.inactive)
        self._state = ContextState.open
        try:
            async with AsyncExitStack() as exit_stack:
                if self._parent:
                    self._parent._child_contexts.add(self)
                    exit_stack.callback(self._parent._child_contexts.remove, self)

                _reset_token = _current_context.set(self)
                exit_stack.callback(_current_context.reset, _reset_token)

                # If this is the root context, create and enter a task group
                if self._parent is None:
                    await exit_stack.enter_async_context(coalesce_exceptions())
                    self._task_group = await exit_stack.enter_async_context(
                        create_task_group()
                    )

                exit_stack.push_async_callback(self._run_teardown_callbacks)
                self._exit_stack = exit_stack.pop_all()
        except BaseException:
            self._state = ContextState.inactive
            raise

        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: TracebackType | None,
    ) -> bool:
        self._state = ContextState.closing
        try:
            retval = await self._exit_stack.__aexit__(exc_type, exc_val, exc_tb)
        finally:
            self._state = ContextState.closed

        if self._child_contexts:
            raise RuntimeError(
                f"Context stack corruption detected: context {id(self):x} still has "
                f"{len(self._child_contexts)} active child context(s)"
            )

        return retval

    def add_resource(
        self,
        value: T_Resource,
        name: str = "default",
        types: type | Sequence[type] = (),
        *,
        description: str | None = None,
        teardown_callback: Callable[[], Any] | None = None,
    ) -> None:
        """
        Add a resource to this context.

        This will cause a ``resource_added`` event to be dispatched.

        :param value: the actual resource value
        :param name: name of this resource (unique among all its registered types within
            a single context)
        :param types: type(s) to register the resource as (omit to use the type of
            ``value``)
        :param description: an optional free-form description, for
            introspection/debugging
        :param teardown_callback: callable that is called to perform cleanup on this
            resource when the context is being shut down
        :raises ResourceConflict: if the resource conflicts with an existing one in any
            way

        """
        self._ensure_state(ContextState.open, ContextState.closing)
        types_: tuple[type, ...]
        if types:
            if (
                isclass(types)
                or get_origin(types) is not None
                or not isinstance(types, Sequence)
            ):
                types_ = (cast(type, types),)
            else:
                types_ = tuple(types)

            if not all(isclass(x) or get_origin(x) is not None for x in types_):
                raise TypeError("types must be a type or sequence of types")
        else:
            types_ = (type(value),)

        if value is None:
            raise ValueError('"value" must not be None')

        if not resource_name_re.fullmatch(name):
            raise ValueError(
                '"name" must be a nonempty string consisting only of alphanumeric '
                "characters and underscores"
            )

        for resource_type in types_:
            if (resource_type, name) in self._resources:
                raise ResourceConflict(
                    f"this context already contains a resource of type "
                    f"{qualified_name(resource_type)} using the name {name!r}"
                )

        container = ResourceContainer(value, types_, name, description)
        for type_ in types_:
            self._resources[(type_, name)] = container

        # Add the teardown callback, if any
        if teardown_callback is not None:
            self.add_teardown_callback(teardown_callback)

        # Notify listeners that a new resource has been made available
        self.resource_added.dispatch(ResourceEvent(types_, name, description, False))

    def add_resource_factory(
        self,
        factory_callback: FactoryCallback,
        name: str = "default",
        *,
        types: type | Sequence[type] = (),
        description: str | None = None,
    ) -> None:
        """
        Add a resource factory to this context.

        This will cause a ``resource_added`` event to be dispatched.

        A resource factory is a callable that generates a "contextual" resource when it
        is requested by either :meth:`get_resource` or :meth:`get_resource_nowait`.

        The type(s) of the generated resources need to be specified, either by passing
        the ``types`` argument, or by adding a return type annotation to the factory
        function. If the generated resource needs to be registered as multiple types,
        you can use :data:`~typing.Union` (e.g. ``Union[str, int]``) or a union type
        (e.g. ``str | int``; requires ``from __future__ import annotations`` on earlier
        than Python 3.10).

        When a new resource is created in this manner, it is always bound to the context
        through it was requested, regardless of where in the chain the factory itself
        was added to.

        :param factory_callback: a (non-coroutine) callable that takes a context
            instance as argument and returns the created resource object
        :param name: name of the resource that will be created in the target context
        :param types: one or more types to register the generated resource as on the
            target context (can be omitted if the factory callable has a return type
            annotation)
        :param description: an optional free-form description, for
            introspection/debugging
        :raises ResourceConflict: if there is an existing resource factory for the given
            type/name combinations or the given context variable

        """
        import types as stdlib_types

        self._ensure_state(ContextState.open)
        if not resource_name_re.fullmatch(name):
            raise ValueError(
                '"name" must be a nonempty string consisting only of alphanumeric '
                "characters and underscores"
            )

        if types:
            if isinstance(types, Sequence):
                resource_types = tuple(types)
            else:
                resource_types = (types,)
        else:
            # Extract the resources types from the return type annotation of the factory
            type_hints = get_type_hints(factory_callback)
            try:
                return_type_hint = type_hints["return"]
            except KeyError:
                raise ValueError(
                    "no resource types specified, and the factory callback does not "
                    "have a return type hint"
                ) from None

            origin = get_origin(return_type_hint)
            if origin is Union or (
                sys.version_info >= (3, 10) and origin is stdlib_types.UnionType
            ):
                resource_types = get_args(return_type_hint)
            else:
                resource_types = (return_type_hint,)

        if None in resource_types:
            raise TypeError("None is not a valid resource type")

        # Check for conflicts with existing resource factories
        for type_ in resource_types:
            if (type_, name) in self._resource_factories:
                raise ResourceConflict(
                    f"this context already contains a resource factory for the "
                    f"type {qualified_name(type_)}"
                )

        # Add the resource factory to the appropriate lookup tables
        resource = ResourceFactory(factory_callback, resource_types, name, description)
        for type_ in resource_types:
            self._resource_factories[(type_, name)] = resource

        # Notify listeners that a new resource has been made available
        self.resource_added.dispatch(
            ResourceEvent(resource_types, name, description, True)
        )

    @overload
    def get_resource_nowait(
        self, type: type[T_Resource], name: str = ..., *, optional: Literal[True]
    ) -> T_Resource | None: ...

    @overload
    def get_resource_nowait(
        self, type: type[T_Resource], name: str = ..., *, optional: Literal[False]
    ) -> T_Resource: ...

    @overload
    def get_resource_nowait(
        self, type: type[T_Resource], name: str = ...
    ) -> T_Resource: ...

    def get_resource_nowait(
        self,
        type: type[T_Resource],
        name: str = "default",
        *,
        optional: Literal[False, True] = False,
    ) -> T_Resource | None:
        """
        Look up a resource in this context.

        This method will not trigger async resource factories.

        :param type: type of the requested resource
        :param name: name of the requested resource
        :param optional: if ``True``, return ``None`` if the resource was not available
        :return: the requested resource, or ``None`` if none was available and
            ``optional`` was ``False``

        """
        self._ensure_state(ContextState.open, ContextState.closing)
        key = (type, name)

        # First check if there's already a matching resource in this context
        resource = self._resources.get(key)
        if resource is not None:
            return cast(T_Resource, resource.value)

        # Next, check if there's a resource factory for this type
        if key in self._resource_factories:
            # Call the factory callback to generate the resource
            factory = self._resource_factories[key]
            generated_resource = factory.callback()

            # Raise AsyncResourceError if the factory returns a coroutine object
            if iscoroutine(generated_resource):
                generated_resource.close()
                raise AsyncResourceError()

            # Store the generated resource in the context
            container = ResourceContainer(
                generated_resource,
                factory.types,
                factory.name,
                factory.description,
                is_generated=True,
            )
            for type_ in factory.types:
                self._resources[(type_, factory.name)] = container

            # Dispatch the resource_added event to notify any listeners
            self.resource_added.dispatch(
                ResourceEvent(factory.types, name, factory.description, False)
            )

            return cast(T_Resource, generated_resource)

        if optional:
            return None

        raise ResourceNotFound(type, name)

    @overload
    async def get_resource(
        self,
        type: type[T_Resource],
        name: str = ...,
        *,
        optional: Literal[True],
    ) -> T_Resource | None: ...

    @overload
    async def get_resource(
        self,
        type: type[T_Resource],
        name: str = ...,
        *,
        optional: Literal[False],
    ) -> T_Resource: ...

    @overload
    async def get_resource(
        self, type: type[T_Resource], name: str = ...
    ) -> T_Resource: ...

    async def get_resource(
        self,
        type: type[T_Resource],
        name: str = "default",
        *,
        optional: Literal[False, True] = False,
    ) -> T_Resource | None:
        """
        Look up a resource in this context.

        :param type: type of the requested resource
        :param name: name of the requested resource
        :param optional: if ``True``, return ``None`` if the resource was not available
        :return: the requested resource, or ``None`` if none was available and
            ``optional`` was ``False``

        """
        self._ensure_state(ContextState.open, ContextState.closing)

        # First check if there's already a matching resource in this context
        key = (type, name)
        if (resource := self._resources.get(key)) is not None:
            return cast(T_Resource, resource.value)

        # Next, check if there's a resource factory for this type
        if key in self._resource_factories:
            factory = self._resource_factories[key]
            generated_resource = factory.callback()
            if isawaitable(generated_resource):
                generated_resource = await generated_resource

            container = ResourceContainer(
                generated_resource,
                factory.types,
                factory.name,
                factory.description,
            )
            for type_ in factory.types:
                self._resources[(type_, factory.name)] = container

            # Dispatch the resource_added event to notify any listeners
            self.resource_added.dispatch(
                ResourceEvent(factory.types, name, factory.description, False)
            )

            return cast(T_Resource, generated_resource)

        if optional:
            return None

        raise ResourceNotFound(type, name)

    def get_resources(self, type: type[T_Resource]) -> Mapping[str, T_Resource]:
        """
        Retrieve all the resources of the given type in this context.

        This method does not trigger resource factories; it only retrieves resources
        already in the context chain.

        :param type: type of the resources to get
        :return: a mapping of resource name to the resource

        """
        # Collect all the matching resources from this context
        return {
            container.name: container.value
            for container in self._resources.values()
            if type in container.types
        }

    async def start_background_task_factory(
        self, *, exception_handler: ExceptionHandler | None = None
    ) -> TaskFactory:
        """
        Start a service task that hosts ad-hoc background tasks.

        Each of the tasks started by this factory is run in its own, separate Asphalt
        context, inherited from this context.

        When the service task is torn down, it will wait for all the background tasks to
        finish before returning.

        It is imperative to ensure that the task factory is set up after any of the
        resources potentially needed by the ad-hoc tasks are set up first. Failing to do
        so risks those resources being removed from the context before all the tasks
        have finished.

        :param exception_handler: a callback called to handle an exception raised from the
            task. Takes the exception (:exc:`Exception`) as the argument, and should return
            ``True`` if it successfully handled the exception.
        :return: the task factory

        .. seealso:: :func:`start_service_task`

        """
        factory = TaskFactory(exception_handler)
        await self.start_service_task(
            factory._run,
            f"Background task factory ({id(factory):x})",
            teardown_action=factory._finished_event.set,
        )
        return factory

    async def start_service_task(
        self,
        func: Callable[..., Coroutine[Any, Any, T_Retval]],
        name: str,
        *,
        teardown_action: TeardownAction = "cancel",
    ) -> Any:
        """
        Start a background task that gets shut down when the context shuts down.

        This function is meant to be used by components to run their tasks like network
        services that should be shut down with the application, because each call to this
        functions registers a context teardown callback that waits for the service task to
        finish before allowing the context teardown to continue.

        If you supply a teardown callback, and it raises an exception, then the task
        will be cancelled instead.

        :param func: the coroutine function to run
        :param name: descriptive name (e.g. "HTTP server") for the task, to which the
            prefix "Service task: " will be added when the task is actually created
            in the backing asynchronous event loop implementation (e.g. asyncio)
        :param teardown_action: the action to take when the context is being shut down:

            * ``'cancel'``: cancel the task
            * ``None``: no action (the task must finish by itself)
            * (function, or any callable, can be asynchronous): run this callable to signal
                the task to finish
        :return: any value passed to ``task_status.started()`` by the target callable if
            it supports that, otherwise ``None``
        """

        async def finalize_service_task() -> None:
            if teardown_action == "cancel":
                logger.debug("Cancelling service task %r", name)
                task_handle.cancel()
            elif teardown_action is not None:
                teardown_action_name = callable_name(teardown_action)
                logger.debug(
                    "Calling teardown callback (%s) for service task %r",
                    teardown_action_name,
                    name,
                )
                try:
                    retval = teardown_action()
                    if isawaitable(retval):
                        await retval
                except BaseException as exc:
                    task_handle.cancel()
                    if isinstance(exc, Exception):
                        logger.exception(
                            "Error calling teardown callback (%s) for service task %r",
                            teardown_action_name,
                            name,
                        )

            logger.debug("Waiting for service task %r to finish", name)
            await task_handle.wait_finished()
            logger.debug("Service task %r finished", name)

        if (
            teardown_action != "cancel"
            and teardown_action is not None
            and not callable(teardown_action)
        ):
            raise ValueError(
                "teardown_action must be a callable, None, or the string 'cancel'"
            )

        task_handle = TaskHandle(f"Service task: {name}")
        task_handle.start_value = await self._task_group.start(
            run_background_task, func, self, task_handle, name=task_handle.name
        )
        self.add_teardown_callback(finalize_service_task)
        return task_handle.start_value


def context_teardown(
    func: Callable[P, AsyncGenerator[None, BaseException | None]],
) -> Callable[P, Coroutine[Any, Any, None]]:
    """
    Wrap an async generator function to execute the rest of the function at context
    teardown.

    This function returns an async function, which, when called, starts the wrapped
    async generator. The wrapped async function is run until the first ``yield``
    statement When the context is being torn down, the exception that ended the context,
    if any, is sent to the generator.

    For example::

        class SomeComponent(Component):
            @context_teardown
            async def start(self, ctx: ComponentContext):
                service = SomeService()
                add_resource(service)
                exception = yield
                service.stop()

    :param func: an async generator function
    :return: an async function
    """

    @wraps(func)
    async def wrapper(*args: P.args, **kwargs: P.kwargs) -> None:
        async def teardown_callback(exception: BaseException | None) -> None:
            try:
                await generator.asend(exception)
            except StopAsyncIteration:
                pass
            finally:
                await generator.aclose()

        ctx = current_context()
        generator = func(*args, **kwargs)
        try:
            await generator.asend(None)
        except StopAsyncIteration:
            pass
        except BaseException:
            await generator.aclose()
            raise
        else:
            ctx.add_teardown_callback(teardown_callback, True)

    if not isasyncgenfunction(func):
        raise TypeError(f"{callable_name(func)} must be an async generator function")

    return wrapper


def current_context() -> Context:
    """
    Return the currently active context.

    :raises NoCurrentContext: if there is no active context

    """
    ctx = _current_context.get()
    if ctx is None:
        raise NoCurrentContext

    return ctx


def add_resource(
    value: T_Resource,
    name: str = "default",
    types: type | Sequence[type] = (),
    *,
    description: str | None = None,
    teardown_callback: Callable[[], Any] | None = None,
) -> None:
    """
    Shortcut for ``current_context().add_resource(...)``.

    .. seealso:: :meth:`Context.add_resource`
    """
    current_context().add_resource(
        value, name, types, description=description, teardown_callback=teardown_callback
    )


def add_resource_factory(
    factory_callback: FactoryCallback,
    name: str = "default",
    *,
    types: type | Sequence[type] = (),
    description: str | None = None,
) -> None:
    """
    Shortcut for ``current_context().add_resource_factory(...)``.

    .. seealso:: :meth:`Context.add_resource_factory`

    """
    current_context().add_resource_factory(
        factory_callback, name, types=types, description=description
    )


def add_teardown_callback(
    callback: TeardownCallback, pass_exception: bool = False
) -> None:
    """
    Shortcut for ``current_context().add_teardown_callback(...)``.

    .. seealso:: :meth:`Context.add_teardown_callback`
    """
    current_context().add_teardown_callback(callback, pass_exception=pass_exception)


def get_resources(type: type[T_Resource]) -> Mapping[str, T_Resource]:
    """
    Shortcut for ``current_context().get_resources(...)``.

    .. seealso:: :meth:`Context.get_resources`

    """
    return current_context().get_resources(type)


@overload
async def get_resource(
    type: type[T_Resource],
    name: str = ...,
    *,
    optional: Literal[True],
) -> T_Resource | None: ...


@overload
async def get_resource(
    type: type[T_Resource],
    name: str = ...,
    *,
    optional: Literal[False],
) -> T_Resource: ...


@overload
async def get_resource(type: type[T_Resource], name: str = ...) -> T_Resource: ...


async def get_resource(
    type: type[T_Resource],
    name: str = "default",
    *,
    optional: Literal[False, True] = False,
) -> T_Resource | None:
    """
    Shortcut for ``current_context().get_resource(...)``.

    .. seealso:: :meth:`Context.get_resource`

    """
    return await current_context().get_resource(type, name, optional=optional)


@overload
def get_resource_nowait(
    type: type[T_Resource], name: str = "default", *, optional: Literal[True]
) -> T_Resource | None: ...


@overload
def get_resource_nowait(
    type: type[T_Resource], name: str = "default", *, optional: Literal[False]
) -> T_Resource: ...


@overload
def get_resource_nowait(
    type: type[T_Resource], name: str = "default"
) -> T_Resource: ...


def get_resource_nowait(
    type: type[T_Resource],
    name: str = "default",
    *,
    optional: Literal[False, True] = False,
) -> T_Resource | None:
    """
    Shortcut for ``current_context().get_resource_nowait(...)``.

    .. seealso:: :meth:`Context.get_resource`

    """
    return current_context().get_resource_nowait(type, name, optional=optional)


async def start_background_task_factory(
    *, exception_handler: ExceptionHandler | None = None
) -> TaskFactory:
    """
    Start a service task that hosts ad-hoc background tasks.

    Each of the tasks started by this factory is run in its own, separate Asphalt
    context, inherited from this context.

    When the service task is torn down, it will wait for all the background tasks to
    finish before returning.

    It is imperative to ensure that the task factory is set up after any of the
    resources potentially needed by the ad-hoc tasks are set up first. Failing to do
    so risks those resources being removed from the context before all the tasks
    have finished.

    :param exception_handler: a callback called to handle an exception raised from the
        task. Takes the exception (:exc:`Exception`) as the argument, and should return
        ``True`` if it successfully handled the exception.
    :return: the task factory

    .. seealso:: :func:`start_service_task`

    """
    return await current_context().start_background_task_factory(
        exception_handler=exception_handler
    )


async def start_service_task(
    func: Callable[..., Coroutine[Any, Any, T_Retval]],
    name: str,
    *,
    teardown_action: TeardownAction = "cancel",
) -> Any:
    """
    Start a background task that gets shut down when the context shuts down.

    This function is meant to be used by components to run their tasks like network
    services that should be shut down with the application, because each call to this
    functions registers a context teardown callback that waits for the service task to
    finish before allowing the context teardown to continue.

    If you supply a teardown callback, and it raises an exception, then the task
    will be cancelled instead.

    :param func: the coroutine function to run
    :param name: descriptive name (e.g. "HTTP server") for the task, to which the
        prefix "Service task: " will be added when the task is actually created
        in the backing asynchronous event loop implementation (e.g. asyncio)
    :param teardown_action: the action to take when the context is being shut down:

        * ``'cancel'``: cancel the task
        * ``None``: no action (the task must finish by itself)
        * (function, or any callable, can be asynchronous): run this callable to signal
            the task to finish
    :return: any value passed to ``task_status.started()`` by the target callable if
        it supports that, otherwise ``None``

    """
    return await current_context().start_service_task(
        func, name, teardown_action=teardown_action
    )


@dataclass
class _Dependency:
    name: str = "default"
    cls: type = field(init=False, repr=False)
    optional: bool = field(init=False, default=False)

    def __getattr__(self, item: str) -> NoReturn:
        raise AttributeError(
            "Attempted to access an attribute in a resource() marker – did you forget "
            "to add the @inject decorator?"
        )


def resource(name: str = "default") -> Any:
    """
    Marker for declaring a parameter for dependency injection via :func:`inject`.

    :param name: the resource name (defaults to ``default``)

    """
    return _Dependency(name)


@overload
def inject(
    func: Callable[P, Coroutine[Any, Any, T_Retval]],
) -> Callable[P, Coroutine[Any, Any, T_Retval]]: ...


@overload
def inject(func: Callable[P, T_Retval]) -> Callable[P, T_Retval]: ...


def inject(func: Callable[P, Any]) -> Callable[P, Any]:
    """
    Wrap the given coroutine function for use with dependency injection.

    Parameters with dependencies need to be annotated and have :func:`resource` as the
    default value. When the wrapped function is called, values for such parameters will
    be automatically filled in by calling :func:`get_resource` using the parameter's
    type annotation and the resource name passed to :func:`resource` (or ``"default"``)
    as the arguments.

    Any forward references among the type annotations are resolved on the first call to
    the wrapped function.

    """
    forward_refs_resolved = False
    local_names = sys._getframe(1).f_locals if "<locals>" in func.__qualname__ else {}

    def resolve_forward_refs() -> None:
        nonlocal forward_refs_resolved, local_names
        type_hints = get_type_hints(func, localns=local_names)
        for key, dependency in injected_resources.items():
            dependency.cls = type_hints[key]
            origin = get_origin(type_hints[key])
            if origin is Union or (
                sys.version_info >= (3, 10) and origin is types.UnionType
            ):
                args = [
                    arg for arg in get_args(dependency.cls) if arg is not type(None)
                ]
                if len(args) == 1:
                    dependency.optional = True
                    dependency.cls = args[0]
                else:
                    raise TypeError(
                        "Unions are only valid with dependency injection when there "
                        "are exactly two items and other item is None"
                    )

        del local_names
        forward_refs_resolved = True

    def resolve_resources() -> dict[str, Any]:
        if not forward_refs_resolved:
            resolve_forward_refs()

        ctx = current_context()
        resources: dict[str, Any] = {}
        for argname, dependency in injected_resources.items():
            if dependency.optional:
                resources[argname] = ctx.get_resource_nowait(
                    dependency.cls, dependency.name, optional=True
                )
            else:
                resources[argname] = ctx.get_resource_nowait(
                    dependency.cls, dependency.name
                )

        return resources

    @wraps(func)
    def sync_wrapper(*args: P.args, **kwargs: P.kwargs) -> Any:
        __tracebackhide__ = True
        return func(*args, **kwargs, **resolve_resources())

    async def resolve_resources_async() -> dict[str, Any]:
        if not forward_refs_resolved:
            resolve_forward_refs()

        ctx = current_context()
        resources: dict[str, Any] = {}
        for argname, dependency in injected_resources.items():
            if dependency.optional:
                resources[argname] = await ctx.get_resource(
                    dependency.cls, dependency.name, optional=True
                )
            else:
                resources[argname] = await ctx.get_resource(
                    dependency.cls, dependency.name
                )

        return resources

    @wraps(func)
    async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> Any:
        __tracebackhide__ = True
        return await func(*args, **kwargs, **await resolve_resources_async())

    sig = signature(func)
    injected_resources: dict[str, _Dependency] = {}
    for param in sig.parameters.values():
        if isinstance(param.default, _Dependency):
            if param.kind is Parameter.POSITIONAL_ONLY:
                raise TypeError(
                    f"Cannot inject dependency to positional-only parameter "
                    f"{param.name!r}"
                )

            if param.annotation is Parameter.empty:
                raise TypeError(
                    f"Dependency for parameter {param.name!r} of function "
                    f"{callable_name(func)!r} is missing the type annotation"
                )

            injected_resources[param.name] = param.default
        elif param.default is resource:
            raise TypeError(
                f"Default value for parameter {param.name!r} of function "
                f"{callable_name(func)} was the 'resource' function – did you forget "
                f"to add the parentheses at the end?"
            )

    if injected_resources:
        if iscoroutinefunction(func):
            return async_wrapper
        else:
            return sync_wrapper
    else:
        warnings.warn(
            f"{callable_name(func)} does not have any injectable resources declared"
        )
        return func
